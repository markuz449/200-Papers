#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <time.h>
#include <ctype.h>
#include "tree.h"
#include "htable.h"
#include "mylib.h"

/**
 * Printf the help message.
 */
void print_help(){
    printf("Usage: ./sample-asgn [OPTIONS]... <STDIN>\n");
    printf("\n");
    printf("Perform tasks using a hash table or binary tree.  ");
    printf("By default, words \n");
    printf("read from stdin are added to the data structure ");
    printf("before printing \n");
    printf("them, along with their frequencies, to stdout.\n");
    printf("\n");
    printf(" -T           Use a tree data structure (default is ");
    printf("hash table)\n");
    printf(" -c FILENAME  Check spelling of words in FILENAME ");
    printf("using words\n");
    printf("              from stdin as dictionary.  Print ");
    printf("unknown words to\n");
    printf("              stdout, timing info etc to stderr ");
    printf("(ignore -o & -p)\n");
    printf(" -d           Use double hashing (linear probing ");
    printf("is the default)\n");
    printf(" -e           Display entire contents of hash ");
    printf("table on stderr\n");
    printf(" -o           Output the tree in DOT form to file ");
    printf("'tree-view.dot'\n");
    printf(" -p           Print hash table stats instead of ");
    printf("frequencies & words\n");
    printf(" -r           Make the tree an RBT (the default ");
    printf("is a BST)\n");
    printf(" -s SNAPSHOTS Show SNAPSHOTS stats snapshots (if ");
    printf("-p is used)\n");
    printf(" -t TABLESIZE Use the first prime >= TABLESIZE as ");
    printf("htable size\n");
    printf("\n");
    printf(" -h           Display this message\n");
    printf("\n");
}

/**
 * Prints a word and its frequency to standard error.
 *
 * @param freq the frequency if the word.
 * @param word the word to be printed.
 */
static void print_info(int freq, char *word) {
    fprintf(stderr, "%-4d %s\n", freq, word);
}

/**
 * Checks if a given candidate is a prime. If it is, return 1. If not,
 * return 0;
 * @param candidate the integer to be checked.
 *
 * @return an int. 1 if prime, 0 if not prime.
 */
int is_prime(int candidate){
    int n = 2;
    
    for(n = 2; n < candidate; n++){
        if (candidate % n == 0){
            return 0;
        }
    }
    return 1;
}

/**
 * Given a starting int, iterates through odd numbers until it finds a
 * prime. Then it returns that prime.
 *
 * @param n the inital int.
 *
 * @return the closest prime larger than or equal to the given n.
 */
int get_next_prime(int n){
    int is_p = 0;
    if ((n % 2) == 0){
        n++;
    }
    while(is_p == 0){
        if(is_prime(n)){
            return n;
        }else{
            n += 2;
        }
    }
    return n;
}
void generate_dot(tree t, FILE* file){
    file = fopen("tree-view.dot", "ab+");
    if (file == NULL){
        printf("Error opening file!\n");
        exit(1);
    }
    printf("Creating dot file 'tree-view.dot'\n");
    tree_output_dot(t, file);

    fclose(file);
}

void print_dictionary(tree t, char* str, FILE* file){
    while (getword(str, sizeof str, file) != EOF){
        if (0 == tree_search(t, str)){
            printf("%s\n", str);
        }
    }
}

void make_tree(char* str, int tree_type, int dictionary,
               int out_type, FILE* file){
    tree t = tree_new();
    while(getword(str, sizeof str, stdin) != EOF){
        t = tree_insert(t, str, tree_type);
        t = tree_fix_root(t);
    }
    if (dictionary == 1){
        print_dictionary(t, str, file);
    } else {
        tree_preorder(t, print_info);
    }
    if (out_type == 1){
        generate_dot(t, file);
    }
    tree_free(t);
}

/**
 * This is the main method. Depending on the combination of optcodes used
 * when running the file the data structure will be a htable or a tree and
 * will output in different ways.
 *
 * Run the file with the optcode -h to find out what the optcodes are.
 *
 * @param argc the number of inputs to main.
 * @param argv an array containing all the inputs where the first input
 * is the program name.
 *
 * @return EXIT_SUCCESS.
 */
int main(int argc, char **argv){
    const char *optstring = "Tc:deoprs:t:h";
    char option;
    char str[256];
    char *command = "";
    htable h = NULL;
    FILE *file = stdout;
    int snap = 10;
    clock_t begin, end;
    int count = 0;
    double time;
    int size_set;
    
    int struct_type = 0;  /* T. Default struct type htable. */
    int dictionary = 0;   /* c. Default false. */
    int hash_type = 0;    /* d. Default hash type linear probing. */
    int display_type = 0; /* e. Default does not print full table. */
    int out_type = 0;     /* o. Default does not make tree pdf. */
    int stats_type = 0;   /* p. Default does not print extended stats. */
    int tree_type = 0;    /* r. Default tree type BST. */
    int table_size = 113; /* t. Default table size 113. */

    /*
     * Checks what commands get given to the program from the terminal.
     */
    while((option = getopt(argc, argv, optstring)) != EOF){
        switch(option){
            case 'T':
                /* opcode: -T changes the data structure from
                   a hash table to a tree. */
                struct_type = 1; 
                break;
            case 'c':
                /* opcode: -c Creates a dictionary from the words given via
                   standard input. Then checks the words in the dictionary
                   against words given in the file.
                   Prints out all misspellings. */
                dictionary = 1;
                command = optarg;
                file = fopen(command, "r");
                break;
            case 'd':
                /* opcode: -d Changes the hashing collision resolution
                   strategy from linear probing to double hashing. */
                hash_type = 1;
                break;
            case 'e':
                /* opcode: -e Prints out the entire contents of the
                   hash table to stderr. Prints out the index, frequency,
                   stats and the key if it exists. */
                display_type = 1;
                break;
            case 'o':
                /* opcode: -o Generates a file 'tree-view.dot' which
                   can be used to represent the tree in a dot format. */
                out_type = 1;
                break;
            case 'p':
                /*opcode: -p Prints out stats info instead of printing
                  the frequencies and words. */
                stats_type = 1;
                break;
            case 'r':
                /*opcode: -r Changes the tree data structure to be a
                  red-black tree data structure instead of a the default
                  binary-search tree. */
                tree_type = 1;
                break;
            case 's':
                /*opcode: -s Displays up to the given amount of snapshots
                  when given -p as an arguement. */
                command = optarg;
                snap = atoi(command);
                if (snap == 0 && command[0] != '0'){
                    snap = 10;
                }
                break;
            case 't':
                /*opcode: -t Changes the table size to the first prime
                  that is greater than or equal to the value given in
                  the terminal. */
                command = optarg;
                size_set = atoi(command);
                if (!(size_set == 0 && command[0] != '0')){
                    table_size = get_next_prime(size_set);
                }
                break;
            case 'h':
                /*opcode: -h Prints out the help message on how to
                  use the program. */
                print_help();
                return EXIT_SUCCESS;
            default:
                /*Prints out the help message on how to use the program
                  as the default or if there is an error in the terminal. */
                print_help();
                return EXIT_SUCCESS;
        }
    }

    /* Depending on the struct_type variable, decides whether
       the htable or tree data structure is to be used. */
    /* htable functions. */
    if (struct_type == 0){

        /* Inserts all of the items into the hash table
           and times how long it takes to insert everything. */
        h = htable_new(table_size, hash_type);
        begin = clock();
        while(getword(str, sizeof str, stdin) != EOF){
            htable_insert(h, str);
        }
        end = clock();
        time = (double)(end - begin) / CLOCKS_PER_SEC;
        
        /* Checks if the -c opcode was selected. */
        if (dictionary == 1){
            begin = clock();
            while (getword(str, sizeof str, file) != EOF){
                if (0 == htable_search(h, str)){
                    printf("%s\n", str);
                    count++;
                }
            }
            end = clock();
            printf("Fill time     : %.6f\n", time);
            printf("Search time   : %.6f\n", (double)(end - begin) / CLOCKS_PER_SEC);
            printf("Unknown words = %d\n", count);
        } else {
            /*Checks if the -e opcode was selected.*/
            if(display_type == 1){
                printf("  Pos  Freq  Stats  Word\n");
                printf("----------------------------------------\n");
                htable_print_entire_table(h);
                if(stats_type == 0){
                    htable_print(h, print_info);
                }
            }
            if(stats_type == 1){
                htable_print_stats(h, file, snap);
            }
            if(display_type == 0 && stats_type == 0){
                htable_print(h, print_info);
            }
        }
        htable_free(h);
        
    /* tree functions. */
    } else {
        make_tree(str, tree_type, dictionary, out_type, file);       
    }
    return EXIT_SUCCESS;
}
